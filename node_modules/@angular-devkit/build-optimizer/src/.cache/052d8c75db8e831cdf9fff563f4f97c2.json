{"remainingRequest":"/Users/xuan/Desktop/satori/web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/xuan/Desktop/satori/web/node_modules/cerialize/dist/serialize.js","dependencies":[{"path":"/Users/xuan/Desktop/satori/web/node_modules/cerialize/dist/serialize.js","mtime":1507642407000},{"path":"/Users/xuan/Desktop/satori/web/node_modules/cache-loader/dist/cjs.js","mtime":1531305126000},{"path":"/Users/xuan/Desktop/satori/web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar win = null;\ntry {\n    win = window;\n}\ncatch (e) {\n    win = global;\n}\n//some other modules might want access to the serialization meta data, expose it here\nvar TypeMap = win.__CerializeTypeMap = new win.Map();\nexports.__TypeMap = TypeMap;\n//convert strings like my_camel_string to myCamelString\nfunction CamelCase(str) {\n    var STRING_CAMELIZE_REGEXP = (/(\\-|_|\\.|\\s)+(.)?/g);\n    return str.replace(STRING_CAMELIZE_REGEXP, function (match, separator, chr) {\n        return chr ? chr.toUpperCase() : '';\n    }).replace(/^([A-Z])/, function (match, separator, chr) {\n        return match.toLowerCase();\n    });\n}\nexports.CamelCase = CamelCase;\n//convert strings like MyCamelString to my_camel_string\nfunction SnakeCase(str) {\n    var STRING_DECAMELIZE_REGEXP = (/([a-z\\d])([A-Z])/g);\n    return str.replace(STRING_DECAMELIZE_REGEXP, '$1_$2').toLowerCase();\n}\nexports.SnakeCase = SnakeCase;\n//convert strings like myCamelCase to my_camel_case\nfunction UnderscoreCase(str) {\n    var STRING_UNDERSCORE_REGEXP_1 = (/([a-z\\d])([A-Z]+)/g);\n    var STRING_UNDERSCORE_REGEXP_2 = (/\\-|\\s+/g);\n    return str.replace(STRING_UNDERSCORE_REGEXP_1, '$1_$2').replace(STRING_UNDERSCORE_REGEXP_2, '_').toLowerCase();\n}\nexports.UnderscoreCase = UnderscoreCase;\n//convert strings like my_camelCase to my-camel-case\nfunction DashCase(str) {\n    var STRING_DASHERIZE_REGEXP = (/([a-z\\d])([A-Z])/g);\n    str = str.replace(/_/g, '-');\n    return str.replace(STRING_DASHERIZE_REGEXP, '$1-$2').toLowerCase();\n}\nexports.DashCase = DashCase;\nfunction deserializeString(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (element) {\n            return element && element.toString() || null;\n        });\n    }\n    else {\n        return value && value.toString() || null;\n    }\n}\nfunction deserializeNumber(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (element) {\n            return parseFloat(element);\n        });\n    }\n    else {\n        return parseFloat(value);\n    }\n}\nfunction deserializeBoolean(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (element) {\n            return Boolean(element);\n        });\n    }\n    else {\n        return Boolean(value);\n    }\n}\nfunction serializeString(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (element) {\n            return element && element.toString() || null;\n        });\n    }\n    else {\n        return value && value.toString() || null;\n    }\n}\nfunction serializeNumber(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (element) {\n            return parseInt(element);\n        });\n    }\n    else {\n        return parseInt(value);\n    }\n}\nfunction serializeBoolean(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (element) {\n            return Boolean(element);\n        });\n    }\n    else {\n        return Boolean(value);\n    }\n}\nfunction getDeserializeFnForType(type) {\n    if (type === String) {\n        return deserializeString;\n    }\n    else if (type === Number) {\n        return deserializeNumber;\n    }\n    else if (type === Boolean) {\n        return deserializeBoolean;\n    }\n    else {\n        return type;\n    }\n}\nfunction getSerializeFnForType(type) {\n    if (type === String) {\n        return serializeString;\n    }\n    else if (type === Number) {\n        return serializeNumber;\n    }\n    else if (type === Boolean) {\n        return serializeBoolean;\n    }\n    else {\n        return type;\n    }\n}\n//gets meta data for a key name, creating a new meta data instance\n//if the input array doesn't already define one for the given keyName\nfunction getMetaData(array, keyName) {\n    for (var i = 0; i < array.length; i++) {\n        if (array[i].keyName === keyName) {\n            return array[i];\n        }\n    }\n    array.push(new MetaData(keyName));\n    return array[array.length - 1];\n}\n//helper for grabbing the type and keyname from a multi-type input variable\nfunction getTypeAndKeyName(keyNameOrType, keyName) {\n    var type = null;\n    var key = null;\n    if (typeof keyNameOrType === \"string\") {\n        key = keyNameOrType;\n    }\n    else if (keyNameOrType && typeof keyNameOrType === \"function\" || typeof keyNameOrType === \"object\") {\n        type = keyNameOrType;\n        key = keyName;\n    }\n    return { key: key, type: type };\n}\n//todo instance.constructor.prototype.__proto__ === parent class, maybe use this?\n//because types are stored in a JS Map keyed by constructor, serialization is not inherited by default\n//keeping this seperate by default also allows sub classes to serialize differently than their parent\nfunction inheritSerialization(parentType) {\n    return function (childType) {\n        var parentMetaData = TypeMap.get(parentType) || [];\n        var childMetaData = TypeMap.get(childType) || [];\n        for (var i = 0; i < parentMetaData.length; i++) {\n            var keyName = parentMetaData[i].keyName;\n            if (!MetaData.hasKeyName(childMetaData, keyName)) {\n                childMetaData.push(MetaData.clone(parentMetaData[i]));\n            }\n        }\n        TypeMap.set(childType, childMetaData);\n    };\n}\nexports.inheritSerialization = inheritSerialization;\n//an untyped serialization property annotation, gets existing meta data for the target or creates\n//a new one and assigns the serialization key for that type in the meta data\nfunction serialize(target, keyName) {\n    if (!target || !keyName)\n        return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, keyName);\n    metadata.serializedKey = keyName;\n    TypeMap.set(target.constructor, metaDataList);\n}\nexports.serialize = serialize;\n//an untyped deserialization property annotation, gets existing meta data for the target or creates\n//a new one and assigns the deserialization key for that type in the meta data\nfunction deserialize(target, keyName) {\n    if (!target || !keyName)\n        return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, keyName);\n    metadata.deserializedKey = keyName;\n    TypeMap.set(target.constructor, metaDataList);\n}\nexports.deserialize = deserialize;\n//this combines @serialize and @deserialize as defined above\nfunction autoserialize(target, keyName) {\n    if (!target || !keyName)\n        return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, keyName);\n    metadata.serializedKey = keyName;\n    metadata.deserializedKey = keyName;\n    TypeMap.set(target.constructor, metaDataList);\n}\nexports.autoserialize = autoserialize;\n//We dont actually need the type to serialize but I like the consistency with deserializeAs which definitely does\n//serializes a type using 1.) a custom key name, 2.) a custom type, or 3.) both custom key and type\nfunction serializeAs(keyNameOrType, keyName) {\n    if (!keyNameOrType)\n        return;\n    var _a = getTypeAndKeyName(keyNameOrType, keyName), key = _a.key, type = _a.type;\n    return function (target, actualKeyName) {\n        if (!target || !actualKeyName)\n            return;\n        var metaDataList = TypeMap.get(target.constructor) || [];\n        var metadata = getMetaData(metaDataList, actualKeyName);\n        metadata.serializedKey = (key) ? key : actualKeyName;\n        metadata.serializedType = type;\n        //this allows the type to be a stand alone function instead of a class\n        if (type !== Date && type !== RegExp && !TypeMap.get(type) && typeof type === \"function\") {\n            metadata.serializedType = {\n                Serialize: getSerializeFnForType(type)\n            };\n        }\n        TypeMap.set(target.constructor, metaDataList);\n    };\n}\nexports.serializeAs = serializeAs;\n//Supports serializing of dictionary-like map objects, ie: { x: {}, y: {} }\nfunction serializeIndexable(type, keyName) {\n    if (!type)\n        return;\n    return function (target, actualKeyName) {\n        if (!target || !actualKeyName)\n            return;\n        var metaDataList = TypeMap.get(target.constructor) || [];\n        var metadata = getMetaData(metaDataList, actualKeyName);\n        metadata.serializedKey = (keyName) ? keyName : actualKeyName;\n        metadata.serializedType = type;\n        metadata.indexable = true;\n        //this allows the type to be a stand alone function instead of a class\n        if (type !== Date && type !== RegExp && !TypeMap.get(type) && typeof type === \"function\") {\n            metadata.serializedType = {\n                Serialize: getSerializeFnForType(type)\n            };\n        }\n        TypeMap.set(target.constructor, metaDataList);\n    };\n}\nexports.serializeIndexable = serializeIndexable;\n//deserializes a type using 1.) a custom key name, 2.) a custom type, or 3.) both custom key and type\nfunction deserializeAs(keyNameOrType, keyName) {\n    if (!keyNameOrType)\n        return;\n    var _a = getTypeAndKeyName(keyNameOrType, keyName), key = _a.key, type = _a.type;\n    return function (target, actualKeyName) {\n        if (!target || !actualKeyName)\n            return;\n        var metaDataList = TypeMap.get(target.constructor) || [];\n        var metadata = getMetaData(metaDataList, actualKeyName);\n        metadata.deserializedKey = (key) ? key : actualKeyName;\n        metadata.deserializedType = type;\n        //this allows the type to be a stand alone function instead of a class\n        //todo maybe add an explicit date and regexp deserialization function here\n        if (!TypeMap.get(type) && type !== Date && type !== RegExp && typeof type === \"function\") {\n            metadata.deserializedType = {\n                Deserialize: getDeserializeFnForType(type)\n            };\n        }\n        TypeMap.set(target.constructor, metaDataList);\n    };\n}\nexports.deserializeAs = deserializeAs;\n//Supports deserializing of dictionary-like map objects, ie: { x: {}, y: {} }\nfunction deserializeIndexable(type, keyName) {\n    if (!type)\n        return;\n    var key = keyName;\n    return function (target, actualKeyName) {\n        if (!target || !actualKeyName)\n            return;\n        var metaDataList = TypeMap.get(target.constructor) || [];\n        var metadata = getMetaData(metaDataList, actualKeyName);\n        metadata.deserializedKey = (key) ? key : actualKeyName;\n        metadata.deserializedType = type;\n        metadata.indexable = true;\n        if (!TypeMap.get(type) && type !== Date && type !== RegExp && typeof type === \"function\") {\n            metadata.deserializedType = {\n                Deserialize: getDeserializeFnForType(type)\n            };\n        }\n        TypeMap.set(target.constructor, metaDataList);\n    };\n}\nexports.deserializeIndexable = deserializeIndexable;\n//serializes and deserializes a type using 1.) a custom key name, 2.) a custom type, or 3.) both custom key and type\nfunction autoserializeAs(keyNameOrType, keyName) {\n    if (!keyNameOrType)\n        return;\n    var _a = getTypeAndKeyName(keyNameOrType, keyName), key = _a.key, type = _a.type;\n    return function (target, actualKeyName) {\n        if (!target || !actualKeyName)\n            return;\n        var metaDataList = TypeMap.get(target.constructor) || [];\n        var metadata = getMetaData(metaDataList, actualKeyName);\n        var serialKey = (key) ? key : actualKeyName;\n        metadata.deserializedKey = serialKey;\n        metadata.deserializedType = type;\n        metadata.serializedKey = serialKey;\n        metadata.serializedType = getSerializeFnForType(type);\n        if (!TypeMap.get(type) && type !== Date && type !== RegExp && typeof type === \"function\") {\n            metadata.deserializedType = {\n                Deserialize: getDeserializeFnForType(type)\n            };\n        }\n        TypeMap.set(target.constructor, metaDataList);\n    };\n}\nexports.autoserializeAs = autoserializeAs;\n//Supports serializing/deserializing of dictionary-like map objects, ie: { x: {}, y: {} }\nfunction autoserializeIndexable(type, keyName) {\n    if (!type)\n        return;\n    var key = keyName;\n    return function (target, actualKeyName) {\n        if (!target || !actualKeyName)\n            return;\n        var metaDataList = TypeMap.get(target.constructor) || [];\n        var metadata = getMetaData(metaDataList, actualKeyName);\n        var serialKey = (key) ? key : actualKeyName;\n        metadata.deserializedKey = serialKey;\n        metadata.deserializedType = type;\n        metadata.serializedKey = serialKey;\n        metadata.serializedType = getSerializeFnForType(type);\n        metadata.indexable = true;\n        if (!TypeMap.get(type) && type !== Date && type !== RegExp && typeof type === \"function\") {\n            metadata.deserializedType = {\n                Deserialize: getDeserializeFnForType(type)\n            };\n        }\n        TypeMap.set(target.constructor, metaDataList);\n    };\n}\nexports.autoserializeIndexable = autoserializeIndexable;\n//helper class to contain serialization meta data for a property, each property\n//in a type tagged with a serialization annotation will contain an array of these\n//objects each describing one property\nvar MetaData = /*@__PURE__*/ (function () {\n    function MetaData(keyName) {\n        this.keyName = keyName;\n        this.serializedKey = null;\n        this.deserializedKey = null;\n        this.deserializedType = null;\n        this.serializedType = null;\n        this.indexable = false;\n    }\n    //checks for a key name in a meta data array\n    MetaData.hasKeyName = function (metadataArray, key) {\n        for (var i = 0; i < metadataArray.length; i++) {\n            if (metadataArray[i].keyName === key)\n                return true;\n        }\n        return false;\n    };\n    //clone a meta data instance, used for inheriting serialization properties\n    MetaData.clone = function (data) {\n        var metadata = new MetaData(data.keyName);\n        metadata.deserializedKey = data.deserializedKey;\n        metadata.serializedKey = data.serializedKey;\n        metadata.serializedType = data.serializedType;\n        metadata.deserializedType = data.deserializedType;\n        metadata.indexable = data.indexable;\n        return metadata;\n    };\n    return MetaData;\n}());\n//merges two primitive objects recursively, overwriting or defining properties on\n//`instance` as they defined in `json`. Works on objects, arrays and primitives\nfunction mergePrimitiveObjects(instance, json) {\n    if (!json)\n        return instance; //if we dont have a json value, just use what the instance defines already\n    if (!instance)\n        return json; //if we dont have an instance value, just use the json\n    //for each key in the input json we need to do a merge into the instance object\n    Object.keys(json).forEach(function (key) {\n        var transformedKey = key;\n        if (typeof deserializeKeyTransform === \"function\") {\n            transformedKey = deserializeKeyTransform(key);\n        }\n        var jsonValue = json[key];\n        var instanceValue = instance[key];\n        if (Array.isArray(jsonValue)) {\n            //in the array case we reuse the items that exist already where possible\n            //so reset the instance array length (or make it an array if it isnt)\n            //then call mergePrimitiveObjects recursively\n            instanceValue = Array.isArray(instanceValue) ? instanceValue : [];\n            instanceValue.length = jsonValue.length;\n            for (var i = 0; i < instanceValue.length; i++) {\n                instanceValue[i] = mergePrimitiveObjects(instanceValue[i], jsonValue[i]);\n            }\n        }\n        else if (jsonValue && typeof jsonValue === \"object\") {\n            if (!instanceValue || typeof instanceValue !== \"object\") {\n                instanceValue = {};\n            }\n            instanceValue = mergePrimitiveObjects(instanceValue, jsonValue);\n        }\n        else {\n            //primitive case, just use straight assignment\n            instanceValue = jsonValue;\n        }\n        instance[transformedKey] = instanceValue;\n    });\n    return instance;\n}\n//takes an array defined in json and deserializes it into an array that ist stuffed with instances of `type`.\n//any instances already defined in `arrayInstance` will be re-used where possible to maintain referential integrity.\nfunction deserializeArrayInto(source, type, arrayInstance) {\n    if (!Array.isArray(arrayInstance)) {\n        arrayInstance = new Array(source.length);\n    }\n    //extend or truncate the target array to match the source array\n    arrayInstance.length = source.length;\n    for (var i = 0; i < source.length; i++) {\n        arrayInstance[i] = DeserializeInto(source[i], type, arrayInstance[i] || new type());\n    }\n    return arrayInstance;\n}\n//takes an object defined in json and deserializes it into a `type` instance or populates / overwrites\n//properties on `instance` if it is provided.\nfunction deserializeObjectInto(json, type, instance) {\n    var metadataArray = TypeMap.get(type);\n    //if we dont have an instance we need to create a new `type`\n    if (instance === null || instance === void 0) {\n        if (type) {\n            instance = new type();\n        }\n    }\n    //if we dont have any meta data and we dont have a type to inflate, just merge the objects\n    if (instance && !type && !metadataArray) {\n        return mergePrimitiveObjects(instance, json);\n    }\n    //if we dont have meta data just bail out and keep what we have\n    if (!metadataArray) {\n        invokeDeserializeHook(instance, json, type);\n        return instance;\n    }\n    //for each property in meta data, try to hydrate that property with its corresponding json value\n    for (var i = 0; i < metadataArray.length; i++) {\n        var metadata = metadataArray[i];\n        //these are not the droids we're looking for (to deserialize), moving along\n        if (!metadata.deserializedKey)\n            continue;\n        var serializedKey = metadata.deserializedKey;\n        if (metadata.deserializedKey === metadata.keyName) {\n            if (typeof deserializeKeyTransform === \"function\") {\n                serializedKey = deserializeKeyTransform(metadata.keyName);\n            }\n        }\n        var source = json[serializedKey];\n        if (source === void 0)\n            continue;\n        var keyName = metadata.keyName;\n        //if there is a custom deserialize function, use that\n        if (metadata.deserializedType && typeof metadata.deserializedType.Deserialize === \"function\") {\n            instance[keyName] = metadata.deserializedType.Deserialize(source);\n        }\n        else if (Array.isArray(source)) {\n            if (metadata.deserializedType) {\n                instance[keyName] = deserializeArrayInto(source, metadata.deserializedType, instance[keyName]);\n            }\n            else {\n                instance[keyName] = deserializeArray(source, null);\n            }\n        }\n        else if ((typeof source === \"string\" || source instanceof Date) && metadata.deserializedType === Date.prototype.constructor) {\n            var deserializedDate = new Date(source);\n            if (instance[keyName] instanceof Date) {\n                instance[keyName].setTime(deserializedDate.getTime());\n            }\n            else {\n                instance[keyName] = deserializedDate;\n            }\n        }\n        else if (typeof source === \"string\" && type === RegExp) {\n            instance[keyName] = new RegExp(source);\n        }\n        else if (source && typeof source === \"object\") {\n            if (metadata.indexable) {\n                instance[keyName] = deserializeIndexableObjectInto(source, metadata.deserializedType, instance[keyName]);\n            }\n            else {\n                instance[keyName] = deserializeObjectInto(source, metadata.deserializedType, instance[keyName]);\n            }\n        }\n        else {\n            instance[keyName] = source;\n        }\n    }\n    //invoke our after deserialized callback if provided\n    invokeDeserializeHook(instance, json, type);\n    return instance;\n}\n//deserializes a bit of json into a `type`\nfunction Deserialize(json, type) {\n    if (Array.isArray(json)) {\n        return deserializeArray(json, type);\n    }\n    else if (json && typeof json === \"object\") {\n        return deserializeObject(json, type);\n    }\n    else if ((typeof json === \"string\" || json instanceof Date) && type === Date.prototype.constructor) {\n        return new Date(json);\n    }\n    else if (typeof json === \"string\" && type === RegExp) {\n        return new RegExp(json);\n    }\n    else {\n        return json;\n    }\n}\nexports.Deserialize = Deserialize;\n//takes some json, a type, and a target object and deserializes the json into that object\nfunction DeserializeInto(source, type, target) {\n    if (Array.isArray(source)) {\n        return deserializeArrayInto(source, type, target || []);\n    }\n    else if (source && typeof source === \"object\") {\n        return deserializeObjectInto(source, type, target || new type());\n    }\n    else {\n        return target || (type && new type()) || null;\n    }\n}\nexports.DeserializeInto = DeserializeInto;\n//deserializes an array of json into an array of `type`\nfunction deserializeArray(source, type) {\n    var retn = new Array(source.length);\n    for (var i = 0; i < source.length; i++) {\n        retn[i] = Deserialize(source[i], type);\n    }\n    return retn;\n}\nfunction invokeDeserializeHook(instance, json, type) {\n    if (type && typeof (type).OnDeserialized === \"function\") {\n        type.OnDeserialized(instance, json);\n    }\n}\nfunction invokeSerializeHook(instance, json) {\n    if (typeof (instance.constructor).OnSerialized === \"function\") {\n        (instance.constructor).OnSerialized(instance, json);\n    }\n}\n//deserialize a bit of json into an instance of `type`\nfunction deserializeObject(json, type) {\n    var metadataArray = TypeMap.get(type);\n    //if we dont have meta data, just decode the json and use that\n    if (!metadataArray) {\n        var inst = null;\n        if (!type) {\n            inst = JSON.parse(JSON.stringify(json));\n        }\n        else {\n            inst = new type(); //todo this probably wrong\n            invokeDeserializeHook(inst, json, type);\n        }\n        return inst;\n    }\n    var instance = new type();\n    //for each tagged property on the source type, try to deserialize it\n    for (var i = 0; i < metadataArray.length; i++) {\n        var metadata = metadataArray[i];\n        if (!metadata.deserializedKey)\n            continue;\n        var serializedKey = metadata.deserializedKey;\n        if (metadata.deserializedKey === metadata.keyName) {\n            if (typeof deserializeKeyTransform === \"function\") {\n                serializedKey = deserializeKeyTransform(metadata.keyName);\n            }\n        }\n        var source = json[serializedKey];\n        var keyName = metadata.keyName;\n        if (source === void 0)\n            continue;\n        if (source === null) {\n            instance[keyName] = source;\n        }\n        else if (metadata.deserializedType && typeof metadata.deserializedType.Deserialize === \"function\") {\n            instance[keyName] = metadata.deserializedType.Deserialize(source);\n        }\n        else if (Array.isArray(source)) {\n            instance[keyName] = deserializeArray(source, metadata.deserializedType || null);\n        }\n        else if ((typeof source === \"string\" || source instanceof Date) && metadata.deserializedType === Date.prototype.constructor) {\n            instance[keyName] = new Date(source);\n        }\n        else if (typeof source === \"string\" && metadata.deserializedType === RegExp) {\n            instance[keyName] = new RegExp(json);\n        }\n        else if (source && typeof source === \"object\") {\n            if (metadata.indexable) {\n                instance[keyName] = deserializeIndexableObject(source, metadata.deserializedType);\n            }\n            else {\n                instance[keyName] = deserializeObject(source, metadata.deserializedType);\n            }\n        }\n        else {\n            instance[keyName] = source;\n        }\n    }\n    invokeDeserializeHook(instance, json, type);\n    return instance;\n}\nfunction deserializeIndexableObject(source, type) {\n    var retn = {};\n    //todo apply key transformation here?\n    Object.keys(source).forEach(function (key) {\n        retn[key] = deserializeObject(source[key], type);\n    });\n    return retn;\n}\nfunction deserializeIndexableObjectInto(source, type, instance) {\n    //todo apply key transformation here?\n    Object.keys(source).forEach(function (key) {\n        instance[key] = deserializeObjectInto(source[key], type, instance[key]);\n    });\n    return instance;\n}\n//take an array and spit out json\nfunction serializeArray(source, type) {\n    var serializedArray = new Array(source.length);\n    for (var j = 0; j < source.length; j++) {\n        serializedArray[j] = Serialize(source[j], type);\n    }\n    return serializedArray;\n}\n//take an instance of something and try to spit out json for it based on property annotaitons\nfunction serializeTypedObject(instance, type) {\n    var json = {};\n    var metadataArray;\n    if (type) {\n        metadataArray = TypeMap.get(type);\n    }\n    else {\n        metadataArray = TypeMap.get(instance.constructor);\n    }\n    for (var i = 0; i < metadataArray.length; i++) {\n        var metadata = metadataArray[i];\n        if (!metadata.serializedKey)\n            continue;\n        var serializedKey = metadata.serializedKey;\n        if (metadata.serializedKey === metadata.keyName) {\n            if (typeof serializeKeyTransform === \"function\") {\n                serializedKey = serializeKeyTransform(metadata.keyName);\n            }\n        }\n        var source = instance[metadata.keyName];\n        if (source === void 0)\n            continue;\n        if (Array.isArray(source)) {\n            json[serializedKey] = serializeArray(source, metadata.serializedType || null);\n        }\n        else if (metadata.serializedType && typeof metadata.serializedType.Serialize === \"function\") {\n            //todo -- serializeIndexableObject probably isn't needed because of how serialize works\n            json[serializedKey] = metadata.serializedType.Serialize(source);\n        }\n        else {\n            var value = Serialize(source);\n            if (value !== void 0) {\n                json[serializedKey] = value;\n            }\n        }\n    }\n    invokeSerializeHook(instance, json);\n    return json;\n}\n//take an instance of something and spit out some json\nfunction Serialize(instance, type) {\n    if (instance === null || instance === void 0)\n        return null;\n    if (Array.isArray(instance)) {\n        return serializeArray(instance, type);\n    }\n    if (type && TypeMap.has(type)) {\n        return serializeTypedObject(instance, type);\n    }\n    if (instance.constructor && TypeMap.has(instance.constructor)) {\n        return serializeTypedObject(instance);\n    }\n    if (instance instanceof Date) {\n        return instance.toISOString();\n    }\n    if (instance instanceof RegExp) {\n        return instance.toString();\n    }\n    if (instance && typeof instance === 'object' || typeof instance === 'function') {\n        var keys = Object.keys(instance);\n        var json = {};\n        for (var i = 0; i < keys.length; i++) {\n            //todo this probably needs a key transform\n            json[keys[i]] = Serialize(instance[keys[i]]);\n        }\n        invokeSerializeHook(instance, json);\n        return json;\n    }\n    return instance;\n}\nexports.Serialize = Serialize;\nfunction GenericDeserialize(json, type) {\n    return Deserialize(json, type);\n}\nexports.GenericDeserialize = GenericDeserialize;\nfunction GenericDeserializeInto(json, type, instance) {\n    return DeserializeInto(json, type, instance);\n}\nexports.GenericDeserializeInto = GenericDeserializeInto;\n//these are used for transforming keys from one format to another\nvar serializeKeyTransform = null;\nvar deserializeKeyTransform = null;\n//setter for deserializing key transform\nfunction DeserializeKeysFrom(transform) {\n    deserializeKeyTransform = transform;\n}\nexports.DeserializeKeysFrom = DeserializeKeysFrom;\n//setter for serializing key transform\nfunction SerializeKeysTo(transform) {\n    serializeKeyTransform = transform;\n}\nexports.SerializeKeysTo = SerializeKeysTo;\n//this is kinda dumb but typescript doesnt treat enums as a type, but sometimes you still\n//want them to be serialized / deserialized, this does the trick but must be called after\n//the enum is defined.\nfunction SerializableEnumeration(e) {\n    e.Serialize = function (x) {\n        return e[x];\n    };\n    e.Deserialize = function (x) {\n        return e[x];\n    };\n}\nexports.SerializableEnumeration = SerializableEnumeration;\n",null]}