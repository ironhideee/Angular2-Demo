{"remainingRequest":"/Users/xuan/Desktop/satori/web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/xuan/Desktop/satori/web/node_modules/@auth0/angular-jwt/src/jwt.interceptor.js","dependencies":[{"path":"/Users/xuan/Desktop/satori/web/node_modules/@auth0/angular-jwt/src/jwt.interceptor.js","mtime":1521085729000},{"path":"/Users/xuan/Desktop/satori/web/node_modules/cache-loader/dist/cjs.js","mtime":1531305126000},{"path":"/Users/xuan/Desktop/satori/web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Injectable, Inject } from '@angular/core';\nimport { JwtHelperService } from './jwthelper.service';\nimport { JWT_OPTIONS } from './jwtoptions.token';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/fromPromise';\nimport 'rxjs/add/operator/mergeMap';\nvar URL = require('url');\nvar JwtInterceptor = /*@__PURE__*/ (function () {\n    function JwtInterceptor(config, jwtHelper) {\n        this.jwtHelper = jwtHelper;\n        this.tokenGetter = config.tokenGetter;\n        this.headerName = config.headerName || 'Authorization';\n        this.authScheme =\n            config.authScheme || config.authScheme === ''\n                ? config.authScheme\n                : 'Bearer ';\n        this.whitelistedDomains = config.whitelistedDomains || [];\n        this.blacklistedRoutes = config.blacklistedRoutes || [];\n        this.throwNoTokenError = config.throwNoTokenError || false;\n        this.skipWhenExpired = config.skipWhenExpired;\n    }\n    JwtInterceptor.prototype.isWhitelistedDomain = function (request) {\n        var requestUrl = URL.parse(request.url, false, true);\n        return (this.whitelistedDomains.findIndex(function (domain) {\n            return typeof domain === 'string'\n                ? domain === requestUrl.host\n                : domain instanceof RegExp ? domain.test(requestUrl.host) : false;\n        }) > -1);\n    };\n    JwtInterceptor.prototype.isBlacklistedRoute = function (request) {\n        var url = request.url;\n        return (this.blacklistedRoutes.findIndex(function (route) {\n            return typeof route === 'string'\n                ? route === url\n                : route instanceof RegExp ? route.test(url) : false;\n        }) > -1);\n    };\n    JwtInterceptor.prototype.handleInterception = function (token, request, next) {\n        var tokenIsExpired;\n        if (!token && this.throwNoTokenError) {\n            throw new Error('Could not get token from tokenGetter function.');\n        }\n        if (this.skipWhenExpired) {\n            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n        }\n        if (token && tokenIsExpired && this.skipWhenExpired) {\n            request = request.clone();\n        }\n        else if (token && this.isWhitelistedDomain(request) && !this.isBlacklistedRoute(request)) {\n            request = request.clone({\n                setHeaders: (_a = {},\n                    _a[this.headerName] = \"\" + this.authScheme + token,\n                    _a)\n            });\n        }\n        return next.handle(request);\n        var _a;\n    };\n    JwtInterceptor.prototype.intercept = function (request, next) {\n        var _this = this;\n        var token = this.tokenGetter();\n        if (token instanceof Promise) {\n            return Observable.fromPromise(token).mergeMap(function (asyncToken) {\n                return _this.handleInterception(asyncToken, request, next);\n            });\n        }\n        else {\n            return this.handleInterception(token, request, next);\n        }\n    };\n    return JwtInterceptor;\n}());\nexport { JwtInterceptor };\n",null]}